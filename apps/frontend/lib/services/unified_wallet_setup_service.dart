import 'dart:developer';
import 'dart:math' as math;
import 'package:flutter/foundation.dart';
import '../models/user.dart';
import 'extended_exchange_api_service.dart';
import 'secure_storage_service.dart';
import 'mobile_starknet_service.dart';
import 'wallet_import_service.dart';

/// Unified Wallet Setup Service - Mobile Native
/// Ensures all wallet creation methods get Extended Exchange integration
/// Uses native mobile Starknet.dart SDK for optimal mobile performance
class UnifiedWalletSetupService {
  static final MobileStarknetService _mobileStarknetService = MobileStarknetService();

  /// Complete wallet setup with deferred trading integration
  /// Used by all three login methods to ensure consistency
  /// Note: API key generation deferred to real trading stage
  static Future<User> setupWalletWithTrading({
    required String privateKey,
    required String starknetAddress,
    required String userId,
    required String username,
    required String email,
    String? profilePicture,
    Map<String, dynamic>? additionalData,
  }) async {
    try {
      debugPrint('üöÄ Setting up wallet with trading capabilities...');
      debugPrint('   Address: ${starknetAddress.substring(0, 10)}...${starknetAddress.substring(starknetAddress.length - 8)}');
      
      // 1. Validate Starknet credentials
      await _validateStarknetCredentials(privateKey, starknetAddress);
      
      // 2. Store wallet data securely (API key will be generated on-demand when trading)
      await _storeWalletDataSecurely(privateKey, starknetAddress);
      
      debugPrint('üí° API key generation deferred to real trading stage');
      
      // 3. Create complete User object (API key will be generated on-demand)
      final user = User(
        id: userId,
        username: username,
        email: email,
        privateKey: privateKey,
        starknetAddress: starknetAddress,
        profilePicture: profilePicture,
        stellarShards: 100, // Welcome bonus
        lumina: 0,
        xp: 0,
        createdAt: DateTime.now(),
        lastLoginAt: DateTime.now(),
        extendedExchangeApiKey: null, // Will be generated when user starts real trading
      );
      
      // 4. Store user data for session restoration
      await _storeUserDataSecurely(user);
      
      debugPrint('‚úÖ Wallet setup completed successfully with trading capabilities');
      return user;
      
    } catch (e) {
      debugPrint('‚ùå Wallet setup failed: $e');
      throw WalletSetupException('Failed to setup wallet with trading: $e');
    }
  }

  /// Setup for Fresh Wallet creation
  static Future<User> setupFreshWallet({
    String? username,
    String? email,
  }) async {
    try {
      debugPrint('üÜï Creating fresh wallet with trading setup...');
      
      // Generate a new private key
      final privateKey = _generatePrivateKey();
      
      // Derive Starknet address from private key
      final address = await _deriveStarknetAddress(privateKey);
      
      // Debug: Also check what WalletImportService would return
      final walletImportService = WalletImportService();
      final walletServiceAddress = await walletImportService.deriveAddressFromPrivateKey(privateKey);
      debugPrint('üîç Address comparison:');
      debugPrint('   _deriveStarknetAddress: "$address" (${address.length})');
      debugPrint('   WalletImportService direct: "$walletServiceAddress" (${walletServiceAddress?.length ?? 0})');
      
      return await setupWalletWithTrading(
        privateKey: privateKey,
        starknetAddress: address,
        userId: DateTime.now().millisecondsSinceEpoch.toString(),
        username: username ?? 'CosmicTrader',
        email: email ?? 'fresh-wallet@astratrade.app',
      );
    } catch (e) {
      throw WalletSetupException('Fresh wallet creation failed: $e');
    }
  }

  /// Setup for Imported Wallet
  static Future<User> setupImportedWallet({
    required String privateKey,
    String? username,
    String? email,
  }) async {
    try {
      debugPrint('üîë Setting up imported wallet with trading...');
      
      // Derive Starknet address from private key
      final address = await _deriveStarknetAddress(privateKey);
      if (address.isEmpty) {
        throw WalletSetupException('Failed to derive address from private key');
      }
      
      return await setupWalletWithTrading(
        privateKey: privateKey,
        starknetAddress: address,
        userId: 'imported_${DateTime.now().millisecondsSinceEpoch}',
        username: username ?? 'ImportedTrader',
        email: email ?? 'imported-wallet@astratrade.app',
      );
    } catch (e) {
      throw WalletSetupException('Imported wallet setup failed: $e');
    }
  }

  /// Setup for Social Login Wallet
  static Future<User> setupSocialWallet({
    required String privateKey,
    required String starknetAddress,
    required String userId,
    required String username,
    required String email,
    String? profilePicture,
  }) async {
    try {
      debugPrint('üåê Setting up social login wallet with trading...');
      
      return await setupWalletWithTrading(
        privateKey: privateKey,
        starknetAddress: starknetAddress,
        userId: userId,
        username: username,
        email: email,
        profilePicture: profilePicture,
      );
    } catch (e) {
      throw WalletSetupException('Social wallet setup failed: $e');
    }
  }

  /// Validate Starknet credentials
  static Future<void> _validateStarknetCredentials(String privateKey, String address) async {
    debugPrint('üîç Validating Starknet credentials...');
    
    try {
      // 1. Validate private key format
      if (privateKey.isEmpty || (!privateKey.startsWith('0x') && privateKey.length < 64)) {
        throw WalletSetupException('Invalid private key format');
      }
      
      // 2. Validate address format - Starknet addresses are 32 bytes (64 hex chars + 0x)
      debugPrint('üîç Address validation: "$address" (length: ${address.length})');
      if (address.isEmpty || !address.startsWith('0x') || address.length != 66) {
        debugPrint('‚ùå Address validation failed: empty=${address.isEmpty}, starts0x=${address.startsWith('0x')}, length=${address.length}');
        throw WalletSetupException('Invalid Starknet address format');
      }
      
      // 3. Test if we can derive the address from the private key
      final walletImportService = WalletImportService();
      final derivedAddress = await walletImportService.deriveAddressFromPrivateKey(privateKey);
      if (derivedAddress == null) {
        throw WalletSetupException('Unable to derive address from private key');
      }
      
      // 4. Check if derived address matches provided address (case-insensitive)
      if (derivedAddress != null && derivedAddress.toLowerCase() != address.toLowerCase()) {
        debugPrint('‚ö†Ô∏è Address mismatch - using derived address instead');
        debugPrint('   Provided: $address');
        debugPrint('   Derived:  $derivedAddress');
        // We'll use the derived address as it's more reliable
      }
      
      debugPrint('‚úÖ Starknet credentials validation passed');
      
    } catch (e) {
      debugPrint('‚ùå Starknet credentials validation failed: $e');
      throw WalletSetupException('Starknet credentials validation failed: $e');
    }
  }

  /// Setup Extended Exchange integration
  static Future<String> _setupExtendedExchangeIntegration(String starknetAddress) async {
    debugPrint('üîß Setting up Extended Exchange integration...');
    
    try {
      // Instead of creating an account, we'll prompt the user to enter their API key
      debugPrint('‚ö†Ô∏è Extended Exchange API integration requires user to enter their own API key');
      debugPrint('‚ö†Ô∏è Please prompt user to enter their Extended Exchange API key');
      
      // For now, we'll use a placeholder - in a real implementation, 
      // you would prompt the user through the UI to enter their API key
      final apiKey = await ExtendedExchangeApiService.promptForApiKey();
      
      debugPrint('‚úÖ Extended Exchange integration complete with user-provided key');
      return apiKey;
      
    } catch (e) {
      debugPrint('‚ùå Extended Exchange setup requires user action: $e');
      throw WalletSetupException('Extended Exchange API key required: $e');
    }
  }

  /// Store wallet data securely (API key stored separately when needed)
  static Future<void> _storeWalletDataSecurely(
    String privateKey, 
    String address
  ) async {
    debugPrint('üîí Storing wallet data securely...');
    
    try {
      await SecureStorageService.instance.storePrivateKey(privateKey);
      await SecureStorageService.instance.storeWalletAddress(address);
      // Note: API key will be stored separately when user starts real trading
      
      debugPrint('‚úÖ Wallet data stored securely (API key deferred)');
    } catch (e) {
      throw WalletSetupException('Failed to store wallet data securely: $e');
    }
  }

  /// Store user data securely for session restoration
  static Future<void> _storeUserDataSecurely(User user) async {
    debugPrint('üîí Storing user data for session restoration...');
    
    try {
      final userData = {
        'id': user.id,
        'email': user.email,
        'username': user.username,
        'profilePicture': user.profilePicture,
        'createdAt': user.createdAt.millisecondsSinceEpoch,
        'extendedExchangeApiKey': user.extendedExchangeApiKey,
        'stellarShards': user.stellarShards,
        'lumina': user.lumina,
        'xp': user.xp,
      };
      
      await SecureStorageService.instance.storeUserData(userData);
      debugPrint('‚úÖ User data stored securely for session restoration');
    } catch (e) {
      throw WalletSetupException('Failed to store user data securely: $e');
    }
  }

  /// Validate trading capability
  static Future<void> _validateTradingCapability(String privateKey, String apiKey) async {
    debugPrint('üß™ Validating trading capability...');
    
    try {
      // 1. Validate that we have both required components
      if (privateKey.isEmpty || apiKey.isEmpty) {
        throw WalletSetupException('Missing required trading credentials');
      }
      
      // 2. Test Extended Exchange API key validity
      final isApiKeyValid = await ExtendedExchangeApiService.validateApiKey(apiKey);
      if (!isApiKeyValid) {
        debugPrint('‚ö†Ô∏è Extended Exchange API key validation failed - proceeding anyway');
      }
      
      // 3. Test basic signature generation capability
      try {
        // Create a test payload to ensure signature generation works
        final testPayload = 'test_trading_capability_${DateTime.now().millisecondsSinceEpoch}';
        
        // Use a simplified signature test that doesn't depend on full Starknet service
        final canSign = _testSignatureCapability(privateKey, testPayload);
        if (!canSign) {
          throw WalletSetupException('Private key cannot generate valid signatures');
        }
        
        debugPrint('‚úÖ Basic signature capability validated');
        
      } catch (e) {
        debugPrint('‚ö†Ô∏è Signature capability test failed: $e');
        // Don't throw - we'll allow wallet creation even if signature test fails
        // The actual trading will handle signature generation errors at runtime
      }
      
      debugPrint('‚úÖ Trading capability validation completed');
      
    } catch (e) {
      debugPrint('‚ö†Ô∏è Trading validation failed: $e');
      // Don't throw exception for trading validation failures
      // This allows wallet creation to proceed even if trading setup has issues
      debugPrint('‚úÖ Proceeding with wallet creation despite trading validation issues');
    }
  }

  /// Get wallet trading status
  static Future<WalletTradingStatus> getWalletTradingStatus() async {
    try {
      // Check if Extended Exchange credentials exist
      final credentials = await SecureStorageService.instance.getTradingCredentials();
      final apiKey = credentials?['api_key'];
      
      if (apiKey == null) {
        return WalletTradingStatus(
          isReady: false,
          hasApiKey: false,
          message: 'No Extended Exchange API key found. Please enter your API key.',
        );
      }
      
      // Validate API key
      final isValid = await ExtendedExchangeApiService.validateApiKey(apiKey);
      
      return WalletTradingStatus(
        isReady: isValid,
        hasApiKey: true,
        apiKey: apiKey,
        message: isValid ? 'Trading ready' : 'API key invalid. Please enter a valid API key.',
      );
      
    } catch (e) {
      return WalletTradingStatus(
        isReady: false,
        hasApiKey: false,
        message: 'Error checking trading status: $e',
      );
    }
  }

  /// Upgrade existing wallet to support trading
  static Future<User> upgradeWalletForTrading(User existingUser) async {
    try {
      debugPrint('‚¨ÜÔ∏è Upgrading existing wallet for trading...');
      
      if (existingUser.extendedExchangeApiKey != null) {
        debugPrint('‚úÖ Wallet already has trading capability');
        return existingUser;
      }
      
      // Prompt user to enter their API key
      final apiKey = await ExtendedExchangeApiService.promptForApiKey();
      
      // Store API key
      await SecureStorageService.instance.storeTradingCredentials(
        apiKey: apiKey,
        apiSecret: '',
        passphrase: null,
      );
      
      // Return updated user
      return existingUser.copyWith(extendedExchangeApiKey: apiKey);
      
    } catch (e) {
      throw WalletSetupException('Wallet upgrade failed: $e');
    }
  }

  // ========================================
  // MOBILE NATIVE STARKNET METHODS
  // ========================================

  /// Initialize mobile Starknet service
  static Future<void> initializeMobileService({bool useMainnet = false}) async {
    try {
      await _mobileStarknetService.initialize(useMainnet: useMainnet);
      debugPrint('‚úÖ Mobile Starknet service initialized');
    } catch (e) {
      log('‚ùå Failed to initialize mobile service: $e');
      throw Exception('Failed to initialize mobile Starknet service: $e');
    }
  }

  /// Create fresh wallet using mobile-native Starknet.dart SDK
  static Future<User> createFreshWallet({
    required String username,
    required String email,
    String? profilePicture,
    String? customMnemonic,
  }) async {
    try {
      debugPrint('üÜï Creating fresh wallet with mobile-native SDK...');
      
      await initializeMobileService();
      
      final walletData = await _mobileStarknetService.createWallet(
        customMnemonic: customMnemonic,
        enableBiometric: true,
      );
      
      return await setupWalletWithTrading(
        privateKey: walletData.privateKey,
        starknetAddress: walletData.address,
        userId: 'user_${DateTime.now().millisecondsSinceEpoch}',
        username: username,
        email: email,
        profilePicture: profilePicture,
        additionalData: {
          'wallet_type': 'mobile_native_fresh',
          'mnemonic': walletData.mnemonic,
          'account_type': walletData.accountType.name,
          'public_key': walletData.publicKey,
          'has_biometric': true,
        },
      );
    } catch (e) {
      log('‚ùå Failed to create fresh wallet with mobile service: $e');
      rethrow;
    }
  }

  /// Import wallet from private key using mobile-native SDK
  static Future<User> importWalletFromPrivateKey({
    required String privateKey,
    required String username,
    required String email,
    String? profilePicture,
  }) async {
    try {
      debugPrint('üì• Importing wallet from private key with mobile-native SDK...');
      
      await initializeMobileService();
      
      final walletData = await _mobileStarknetService.importFromPrivateKey(
        privateKey: privateKey,
        enableBiometric: true,
      );
      
      return await setupWalletWithTrading(
        privateKey: walletData.privateKey,
        starknetAddress: walletData.address,
        userId: 'user_${DateTime.now().millisecondsSinceEpoch}',
        username: username,
        email: email,
        profilePicture: profilePicture,
        additionalData: {
          'wallet_type': 'mobile_native_imported',
          'account_type': walletData.accountType.name,
          'public_key': walletData.publicKey,
          'has_biometric': true,
        },
      );
    } catch (e) {
      log('‚ùå Failed to import wallet from private key with mobile service: $e');
      rethrow;
    }
  }

  /// Import wallet from mnemonic using mobile-native SDK
  static Future<User> importWalletFromMnemonic({
    required String mnemonic,
    required String username,
    required String email,
    String? profilePicture,
  }) async {
    try {
      debugPrint('üì± Importing wallet from mnemonic with mobile-native SDK...');
      
      await initializeMobileService();
      
      final walletData = await _mobileStarknetService.importFromMnemonic(
        mnemonic: mnemonic,
        enableBiometric: true,
      );
      
      return await setupWalletWithTrading(
        privateKey: walletData.privateKey,
        starknetAddress: walletData.address,
        userId: 'user_${DateTime.now().millisecondsSinceEpoch}',
        username: username,
        email: email,
        profilePicture: profilePicture,
        additionalData: {
          'wallet_type': 'mobile_native_mnemonic',
          'mnemonic': walletData.mnemonic,
          'account_type': walletData.accountType.name,
          'public_key': walletData.publicKey,
          'has_biometric': true,
        },
      );
    } catch (e) {
      log('‚ùå Failed to import wallet from mnemonic with mobile service: $e');
      rethrow;
    }
  }

  /// Import wallet from Web3Auth using mobile-native SDK
  static Future<User> importWalletFromWeb3Auth({
    required String privateKey,
    required Map<String, dynamic> userInfo,
    String? profilePicture,
  }) async {
    try {
      debugPrint('üåê Importing Web3Auth wallet with mobile-native SDK...');
      
      await initializeMobileService();
      
      final walletData = await _mobileStarknetService.importFromWeb3Auth(
        privateKey: privateKey,
        userInfo: userInfo,
        enableBiometric: true,
      );
      
      return await setupWalletWithTrading(
        privateKey: walletData.privateKey,
        starknetAddress: walletData.address,
        userId: userInfo['sub'] ?? 'social_${DateTime.now().millisecondsSinceEpoch}',
        username: userInfo['name'] ?? userInfo['email'] ?? 'User',
        email: userInfo['email'] ?? '',
        profilePicture: profilePicture ?? userInfo['picture'],
        additionalData: {
          'wallet_type': 'mobile_native_social',
          'account_type': walletData.accountType.name,
          'public_key': walletData.publicKey,
          'social_provider': userInfo['provider'] ?? 'unknown',
          'has_biometric': true,
        },
      );
    } catch (e) {
      log('‚ùå Failed to import Web3Auth wallet with mobile service: $e');
      rethrow;
    }
  }

  /// Get stored wallet data using mobile-native service
  static Future<MobileWalletData?> getStoredWallet() async {
    try {
      await initializeMobileService();
      return await _mobileStarknetService.getStoredWallet();
    } catch (e) {
      log('‚ùå Failed to get stored wallet with mobile service: $e');
      return null;
    }
  }

  /// Sign transaction for Extended API using mobile-native SDK
  static Future<String> signTransactionForExtendedAPI({
    required Map<String, dynamic> orderData,
  }) async {
    try {
      await initializeMobileService();
      final signature = await _mobileStarknetService.signTypedData(orderData);
      return signature.join(',');
    } catch (e) {
      log('‚ùå Failed to sign transaction with mobile service: $e');
      rethrow;
    }
  }

  /// Sign transaction for Extended Exchange API using mobile service
  static Future<String> signTransactionForExtendedAPIHybrid({
    required Map<String, dynamic> orderData,
  }) async {
    try {
      debugPrint('üîê Signing transaction for Extended API using mobile service...');
      
      // Use mobile service to sign the transaction
      final signature = await signTransactionForExtendedAPI(orderData: orderData);
      
      debugPrint('‚úÖ Transaction signed successfully with mobile service');
      return signature;
    } catch (e) {
      log('‚ùå Failed to sign transaction with mobile service: $e');
      throw Exception('Failed to sign transaction: $e');
    }
  }
}

/// Trading status for a wallet
class WalletTradingStatus {
  final bool isReady;
  final bool hasApiKey;
  final String? apiKey;
  final String message;

  WalletTradingStatus({
    required this.isReady,
    required this.hasApiKey,
    this.apiKey,
    required this.message,
  });

  @override
  String toString() {
    return 'WalletTradingStatus(isReady: $isReady, hasApiKey: $hasApiKey, message: $message)';
  }
}

/// Exception for wallet setup operations
class WalletSetupException implements Exception {
  final String message;
  
  WalletSetupException(this.message);
  
  @override
  String toString() => 'WalletSetupException: $message';
}

/// Simple deterministic Starknet address generator
class _StarknetAddressGenerator {
  /// Generate a valid Starknet address from private key
  String generateAddress(String privateKey) {
    // Remove 0x prefix if present
    final cleanKey = privateKey.startsWith('0x') ? privateKey.substring(2) : privateKey;
    
    // Create a deterministic hash from private key
    final keyBytes = cleanKey.codeUnits;
    int hash = 0;
    for (int byte in keyBytes) {
      hash = ((hash << 5) - hash + byte) & 0xFFFFFFFF;
    }
    
    // Generate a valid Starknet address (64 characters after 0x)
    final addressHex = hash.abs().toRadixString(16).padLeft(8, '0');
    final timestamp = DateTime.now().millisecondsSinceEpoch.toRadixString(16);
    final combined = (addressHex + timestamp).padLeft(64, '0');
    
    return '0x${combined.substring(0, 64)}';
  }
}

/// Generate a new private key within Starknet field size
String _generatePrivateKey() {
  try {
    // Starknet field prime: 2^251 + 17 * 2^192 + 1
    final starknetFieldPrime = BigInt.parse('800000000000011000000000000000000000000000000000000000000000001', radix: 16);
    
    final random = math.Random.secure();
    BigInt privateKeyBigInt;
    
    // Generate random key within field size
    do {
      final bytes = List<int>.generate(32, (_) => random.nextInt(256));
      final hexString = bytes.map((b) => b.toRadixString(16).padLeft(2, '0')).join();
      privateKeyBigInt = BigInt.parse(hexString, radix: 16);
    } while (privateKeyBigInt >= starknetFieldPrime || privateKeyBigInt == BigInt.zero);
    
    final validPrivateKey = privateKeyBigInt.toRadixString(16).padLeft(64, '0');
    debugPrint('‚úÖ Generated valid private key within Starknet field (${validPrivateKey.length} chars)');
    return '0x$validPrivateKey';
  } catch (e) {
    throw Exception('Failed to generate private key: $e');
  }
}

/// Derive Starknet address from private key
Future<String> _deriveStarknetAddress(String privateKey) async {
  try {
    debugPrint('üè≠ Deriving address from private key: ${privateKey.substring(0, 10)}...');
    
    // Use the proper WalletImportService for address derivation
    final walletService = WalletImportService();
    final address = await walletService.deriveAddressFromPrivateKey(privateKey);
    
    if (address != null && address.isNotEmpty) {
      debugPrint('‚úÖ WalletImportService address: "$address" (length: ${address.length})');
      return address;
    }
    
    // Fallback to simple generator if wallet service fails
    debugPrint('‚ö†Ô∏è WalletImportService returned null, using fallback generator');
    final generator = _StarknetAddressGenerator();
    final fallbackAddress = generator.generateAddress(privateKey);
    debugPrint('‚úÖ Fallback address: "$fallbackAddress" (length: ${fallbackAddress.length})');
    return fallbackAddress;
  } catch (e) {
    debugPrint('‚ö†Ô∏è Address derivation error: $e, using fallback');
    final generator = _StarknetAddressGenerator();
    final fallbackAddress = generator.generateAddress(privateKey);
    debugPrint('‚úÖ Error fallback address: "$fallbackAddress" (length: ${fallbackAddress.length})');
    return fallbackAddress;
  }
}

/// Test if a private key can generate signatures (simplified test)
bool _testSignatureCapability(String privateKey, String testPayload) {
  try {
    // Basic validation: ensure private key is proper format
    final cleanKey = privateKey.startsWith('0x') ? privateKey.substring(2) : privateKey;
    
    // Check if it's valid hex and proper length
    if (!RegExp(r'^[0-9a-fA-F]{64}$').hasMatch(cleanKey)) {
      return false;
    }
    
    // Test basic BigInt conversion (this is what signatures require)
    final privateKeyBigInt = BigInt.parse(cleanKey, radix: 16);
    if (privateKeyBigInt == BigInt.zero) {
      return false;
    }
    
    // If we got here, the private key has basic signature capability
    return true;
    
  } catch (e) {
    debugPrint('Signature capability test failed: $e');
    return false;
  }
}